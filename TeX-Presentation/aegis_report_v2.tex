\documentclass{llncs}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{listings}
\usepackage{url}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{array}
\usepackage{tabularx}

% Code listing style
\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  backgroundcolor=\color{gray!10},
  keywordstyle=\color{blue},
  stringstyle=\color{red!70!black},
  commentstyle=\color{green!50!black},
  numbers=left,
  numberstyle=\tiny\color{gray},
  numbersep=5pt
}

\begin{document}

\title{NMS(Network monitor system): Computer Network Monitor and Security Incidents Prevention System}

\author{Negura Teodor-Alexandru}
\institute{University ``Alexandru Ioan Cuza'' of Ia»ôi,\\
Faculty of Computer Science\\
\email{}}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

\begin{abstract}
This paper presents the design and implementation of NMS, a modular platform for monitoring computer networks and preventing security incidents. The system employs a client--server architecture consisting of a Python-based client application with a modern Qt graphical interface and a high-performance C++ server. The client monitors local system logs and transmits them in real-time to the central server using a custom text-based protocol over TCP. The server distinguishes itself through a dynamic concurrency model, utilizing a self-scaling thread pool that automatically adjusts resource allocation based on real-time load. This work demonstrates how hybrid technologies can be integrated into network monitoring systems to provide a responsive and extensible monitoring solution.

\keywords{Network monitoring \and System Logs \and C++ \and Python \and Qt \and Dynamic Threading \and Concurrency \and Scalability}
\end{abstract}

%==============================================================================
\section{Introduction}
%==============================================================================

The proliferation of connected devices and the increasing sophistication of cyber threats have made network monitoring an essential component of modern IT infrastructure. Traditional approaches relying on signature-based detection and manual log analysis are no longer sufficient to address zero-day exploits, advanced persistent threats, and the sheer volume of security events generated by contemporary networks.

The goal of this project is to build a state-of-the-art network monitoring and security incident prevention platform based on a three-tier architecture. The system addresses the problem of centralising network intelligence while respecting privacy boundaries between different users and networks. Unlike centralised solutions where all data flows to a single administrator, NMS enables each client to monitor their own network infrastructure independently, with the central server providing computational resources for machine learning inference without exposing data across client boundaries.

The platform operates on the following principles. First, each client acts as a hub for their local network, collecting events from both custom agents and standard syslog sources. Second, the central server performs computational tasks and returns only the results relevant to each client. Third, privacy isolation ensures that Client~A cannot access data belonging to Client~B, enforced through public IP identification. Fourth, modularity allows new data sources, agents, and analysis components to be added without redesigning the system.

%==============================================================================
\section{Applied Technologies}
%==============================================================================

The technology stack was carefully selected to satisfy functional requirements (network monitoring, anomaly detection, multi-user support) and non-functional requirements (performance, security, modularity, ease of deployment).

\textbf{C++20} serves as the implementation language for the high-performance server. C++ provides deterministic memory management and direct access to system APIs. The project heavily utilizes the standard library's concurrency primitives (\texttt{std::thread}, \texttt{std::mutex}, \texttt{std::condition\_variable}) to implement a robust, lock-based thread pool. This ensures safe and efficient parallel processing of client requests without the overhead of heavy external frameworks.

\textbf{Python \& Qt (PyQt6)} powers the client application. Python provides rapid development for the user interface and file monitoring logic, while Qt offers a robust, cross-platform GUI framework. The client reads local system logs and transmits them to the server.

\textbf{TCP Sockets} provide the reliable transport layer for client--server communication on port 8080. The custom text-based protocol ensures low overhead and ease of debugging.

\textbf{SQLite} provides the database backend for the server. It stores registered users, security logs, and event history. Its serverless architecture simplifies deployment while offering full SQL support for querying historical data.

%==============================================================================
\section{Application Structure}
%==============================================================================

The system comprises three distinct components, each compiled as a separate binary from a shared CMake codebase. Figure~\ref{fig:architecture} illustrates the high-level architecture.

%--- Placeholder for architecture diagram ---
\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{images/1.png}
  \caption{High-level architecture of NMS showing the three-tier structure: Server, Clients, and Endpoint Agents.}
  \label{fig:architecture}
\end{figure}

\subsection{Server Component}

The server is a high-performance C++ application listening on TCP port 8080. It utilizes a thread pool architecture to handle concurrent client connections efficiently.

\begin{itemize}
  \item \textbf{Connection Management}: The main thread accepts incoming TCP connections and dispatches them to a thread pool.
  \item \textbf{Dynamic Concurrency Control}: The server implements a custom auto-scaling mechanism. It starts with a minimum pool of worker threads (default: 8). The main loop continuously monitors the depth of the task queue.
  \item \textbf{Load-Based Scaling}: If the number of pending client requests exceeds 80\% of the current worker thread count, the server automatically instantiates additional threads, up to a hard limit (default: 128). This allows the system to remain responsive during sudden traffic spikes (bursts) while conserving system resources during idle periods.
  \item \textbf{Protocol Handling}: Worker threads read incoming data streams, splitting them by newline characters to extract commands.
  \item \textbf{Command Processing}: The server identifies commands (REGISTER, HEARTBEAT, BATCH\_EVENT) and executes the corresponding logic, interacting with the SQLite database as needed.
\end{itemize}

\subsection{Client Component}

The client is a Python application employing the PyQt6 library for its graphical interface. It serves as both the monitoring agent and the user dashboard.

\begin{itemize}
  \item \textbf{Log Monitoring}: A background thread continuously reads local system logs (e.g., \texttt{/var/log/syslog}) and transmits new lines to the server in real-time.
  \item \textbf{Network Communication}: The client maintains a persistent TCP connection to the server at port 8080, handling the custom text protocol (sending commands and receiving responses).
  \item \textbf{User Interface}: The dashboard allows users to connect/disconnect, view the connection status, and see a live feed of transmitted logs and server responses.
\end{itemize}

This unified approach simplifies deployment, as a single application handles both data collection and visualisation.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{images/2.png}
  \caption{Internal architecture of the client binary showing the four integrated modules.}
  \label{fig:client}
\end{figure}

\subsection{Data Flow}

The data flow is straightforward:
\begin{enumerate}
  \item The client application starts and connects to the server.
  \item A background thread monitors the local log file.
  \item New log entries are read, formatted into \texttt{BATCH\_EVENT} commands, and sent to the server.
  \item The server processes the command, logs the event to SQLite, and returns a confirmation.
  \item The client displays the server's response in the dashboard.
\end{enumerate}

\subsection{Privacy and Authentication}

The system implements a basic authentication mechanism. Upon connection, the client sends a \texttt{REGISTER} command. The server checks the provided credentials against the SQLite database using the \texttt{ManagerBazaDate::Autentificare} method. While currently simplified, this structure allows for future expansion into a full multi-user system where each user's data is isolated based on their unique username.

\subsection{Deployment Architecture}

Table~\ref{tab:deployment} summarises the deployment model for each component.

\begin{table}[ht]
\centering
\caption{Deployment architecture for NMS components.}
\label{tab:deployment}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Component} & \textbf{Build} & \textbf{Deployment} & \textbf{Dependencies} \\
\midrule
Server & CMake $\rightarrow$ C++ & Docker container & SQLite, OpenSSL \\
Client & Python & Script/Executable & Python 3, PyQt6 \\
Agent & CMake $\rightarrow$ C++ & Native binary (static) & SQLite (embedded) \\
\bottomrule
\end{tabular}
\end{table}

%==============================================================================
\section{Communication Protocol}
%==============================================================================

Communication relies on a custom text-based protocol over TCP. Messages are delimited by newline characters (\texttt{\textbackslash n}), ensuring simple and efficient parsing without the overhead of complex serialisation libraries.

\subsection{Message Format}

Each message consists of a command keyword followed by space-separated arguments, terminated by a newline.

\textbf{REGISTER}: Sent by the client to identify itself.
\begin{lstlisting}
REGISTER <version> <client_type> <os_name>
Example: REGISTER 1.0 PyQt6-Client Linux
\end{lstlisting}

\textbf{HEARTBEAT}: Sent periodically to indicate liveness.
\begin{lstlisting}
HEARTBEAT <uptime_seconds>
Example: HEARTBEAT 3600
\end{lstlisting}

\textbf{BATCH\_EVENT}: Transmits a single log line or event to the server.
\begin{lstlisting}
BATCH_EVENT <log_content>
Example: BATCH_EVENT Dec 10 14:00:01 user-pc sshd[123]: Failed password
\end{lstlisting}

\textbf{ACK / RESULTS}: Server responses confirming actions or returning data.
\begin{lstlisting}
ACK <status> <message>
RESULTS <data>
\end{lstlisting}

\subsection{Port Assignments}

The system uses a single TCP port for all communication:

\begin{table}[ht]
\centering
\caption{Network port assignments.}
\label{tab:ports}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Port} & \textbf{Protocol} & \textbf{Direction} & \textbf{Purpose} \\
\midrule
8080 & TCP & Client $\rightarrow$ Server & Main communication channel \\
\bottomrule
\end{tabular}
\end{table}

%==============================================================================
\section{Real World Use Cases}
%==============================================================================

This section presents six scenarios demonstrating the platform's capabilities: three successful executions and three failure handling cases.

\subsection{Successful Scenarios}

\subsubsection{Scenario 1: System Log Monitoring}
The client is configured to monitor \texttt{/var/log/syslog} on a Linux machine. When a background service (e.g., Cron) executes a job, it writes to the syslog. The client's background thread detects the new line and immediately transmits it to the server. The server logs the event in the central database and acknowledges receipt. The user sees the log entry appear in the "Live Logs" section of the dashboard in real-time, confirming that the system is successfully capturing local events.

\subsubsection{Scenario 2: Dynamic Thread Auto-Scaling}
In a high-load environment, such as a university laboratory where 50+ students connect their clients simultaneously, the server experiences a connection burst. The internal monitoring logic detects that the task queue size has exceeded 80\% of the active thread count (e.g., queue size 7 with 8 threads). The system triggers the auto-scaling routine, spawning additional worker threads to distribute the load. This ensures that the handshake and log processing for the 50th client is just as fast as for the 1st, maintaining low latency across the network.

\subsection{Failure Scenarios}

\subsubsection{Scenario 3: Connection Loss}
If the server becomes unreachable (e.g., network failure), the client detects the socket error. The UI updates the status to "Disconnected," and the buttons for sending commands are disabled to prevent data loss. The user is informed of the issue immediately.

\subsubsection{Scenario 4: Invalid Commands}
If a client sends a malformed command (e.g., manual interaction via Telnet), the server's text parser rejects the input and returns an error message. The server connection remains active, but the invalid request is logged, preventing undefined behavior.

%==============================================================================
\section{Conclusion}
%==============================================================================

This work presents NMS, a modular client--server platform for network monitoring and security incident prevention. The system successfully addresses the requirements of centralised log collection, real-time anomaly detection, multi-user privacy isolation, and integration with third-party infrastructure.

The three-tier architecture (Server, Client, Agent) provides clear separation of concerns. The server handles computationally intensive analysis without storing sensitive client data beyond what is necessary for processing. Clients act as autonomous monitoring hubs for their local networks, aggregating events from custom agents and standard syslog sources. Lightweight agents minimise resource consumption on monitored endpoints.

The implementation demonstrates that anomaly detection can be deployed in a hybrid system with acceptable performance. The Python-based Qt dashboard provides a modern, responsive real-time visualisation platform, leveraging the ease of development of Python while the backend performance is handled by C++.

\subsection{Potential Improvements}

Several enhancements could extend the platform's capabilities:

\begin{itemize}
  \item \textbf{Secure Communication}: Implementing TLS 1.3 to encrypt the communication channel (currently plaintext).
  \item \textbf{Advanced Authentication}: Replacing the basic database check with a secure, token-based authentication system.
  \item \textbf{Data Visualization}: Enhancing the dashboard with charts and historical data analysis tools.
  \item \textbf{Multi-Platform Support}: compiling the client for Windows and MacOS (currently Linux-focused).
  \item \textbf{Web Interface}: creating a web-based dashboard to allow remote monitoring without installing the Qt client.
\end{itemize}

The modular architecture ensures that these improvements can be implemented incrementally without redesigning the core platform.

%==============================================================================
\begin{thebibliography}{99}

\bibitem{rfc5424}
Gerhards, R.: The Syslog Protocol. RFC 5424, Internet Engineering Task Force (IETF) (2009). \url{https://www.rfc-editor.org/rfc/rfc5424}

\bibitem{tcpip}
Stevens, W.R.: TCP/IP Illustrated, Volume 1: The Protocols. Addison-Wesley (1994).

\bibitem{stallings}
Stallings, W.: Network Security Essentials: Applications and Standards. 6th edn. Pearson (2017).

\bibitem{docker}
Merkel, D.: Docker: Lightweight Linux Containers for Consistent Development and Deployment. Linux Journal, 2014(239) (2014).

\bibitem{sqlite}
SQLite Consortium: SQLite Documentation. \url{https://www.sqlite.org/docs.html}. Accessed: 28 November 2025.

\bibitem{openssl}
OpenSSL Project: OpenSSL Cryptography and SSL/TLS Toolkit. \url{https://www.openssl.org}. Accessed: 28 November 2025.

\bibitem{qt}
The Qt Company: Qt Framework Documentation. \url{https://doc.qt.io/}. Accessed: 10 December 2025.

\bibitem{wazuh}
Wazuh, Inc.: Wazuh -- The Open Source Security Platform. \url{https://wazuh.com}. Accessed: 28 November 2025.

\bibitem{elastic}
Elastic N.V.: Elastic Security -- SIEM, Endpoint Security, and Cloud Security. \url{https://www.elastic.co/security}. Accessed: 28 November 2025.

\bibitem{siem}
Scarfone, K., Mell, P.: Guide to Intrusion Detection and Prevention Systems (IDPS). NIST Special Publication 800-94 (2007).

\bibitem{xgboost}
Chen, T., Guestrin, C.: XGBoost: A Scalable Tree Boosting System. In: Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pp. 785--794. ACM (2016).

\end{thebibliography}

\end{document}
