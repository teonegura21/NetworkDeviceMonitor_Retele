\documentclass[11pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{listings}
\usepackage{url}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{array}
\usepackage{tabularx}
\usepackage{float}

% Code listing style
\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  backgroundcolor=\color{gray!10},
  keywordstyle=\color{blue},
  stringstyle=\color{red!70!black},
  commentstyle=\color{green!50!black},
  numbers=left,
  numberstyle=\tiny\color{gray},
  numbersep=5pt
}

\begin{document}

\begin{center}
{\LARGE\bfseries NMS (Network Monitor System):\\Computer Network Monitor and Log Collection Platform}\\[0.5cm]
{\large Negura Teodor-Alexandru}\\[0.3cm]
{\small University ``Alexandru Ioan Cuza'' of Ia»ôi, Faculty of Computer Science}
\end{center}
\vspace{0.5cm}

\begin{abstract}
This paper presents the design and implementation of NMS, a modular platform for monitoring computer networks and collecting system logs. The system employs a client--server architecture consisting of a multi-threaded C++ server with SQLite database storage, and a Python-based graphical client using PyQt6. The platform uses a simple text-based protocol over TCP for communication, enabling real-time log collection from system sources such as \texttt{/var/log/syslog}. Key features include user authentication against the database, automatic log monitoring with background threads, and a modern dark-themed graphical interface designed with Qt Designer. This work demonstrates how traditional network monitoring can be implemented efficiently using modern C++ threading, Python GUI frameworks, and lightweight embedded databases.

\textbf{Keywords:} Network monitoring, Syslog, C++, Python, PyQt6, SQLite, Client--Server, Multi-threading
\end{abstract}

%==============================================================================
\section{Introduction}
%==============================================================================

The proliferation of connected devices and the increasing complexity of IT infrastructure have made network monitoring an essential component of system administration. Log collection and analysis provide crucial visibility into system health, security events, and operational issues.

The goal of this project is to build a functional network monitoring platform based on a client--server architecture. The system addresses the fundamental requirements of centralised log collection, user authentication, and real-time visualisation of monitoring data.

The platform operates on the following principles. First, the server acts as a central collection point for logs from multiple clients. Second, each client monitors its local system logs and transmits them to the server. Third, user authentication ensures that only authorised users can access the system. Fourth, a graphical interface provides real-time visibility into collected data.

\subsection{Inspiration: Wazuh Security Platform}

This project draws significant inspiration from \textbf{Wazuh}~\cite{wazuh}, an open-source security monitoring platform widely used in enterprise environments. Wazuh provides comprehensive capabilities for threat detection, integrity monitoring, incident response, and compliance management.

Key aspects adopted from Wazuh's architecture include:

\begin{itemize}
  \item \textbf{Agent-Server Model}: Like Wazuh, NMS uses lightweight agents (clients) that collect local logs and forward them to a central server for processing and storage.
  \item \textbf{C++ Implementation}: Wazuh's core components are written in C++, demonstrating that high-performance security software benefits from low-level system access and efficient memory management.
  \item \textbf{Syslog Integration}: Wazuh's log collector (\texttt{logcollector}) monitors system log files such as \texttt{/var/log/syslog}, \texttt{/var/log/auth.log}, and custom paths---a pattern replicated in NMS.
  \item \textbf{Protocol Design}: The command-based protocol (REGISTER, HEARTBEAT, events) mirrors Wazuh's agent-manager communication patterns.
  \item \textbf{SQLite for Local Storage}: Both systems use embedded SQLite databases for lightweight, file-based storage without external database dependencies.
\end{itemize}

Being open-source (GPL v2), Wazuh's codebase~\cite{wazuh-github} served as a valuable reference for understanding production-grade security software architecture. The modular separation between log collection, command processing, and database storage in NMS directly reflects patterns observed in Wazuh's source code.

While Wazuh is a complete enterprise solution with advanced features (OSSEC rules, Elastic integration, compliance dashboards), NMS represents a simplified educational implementation demonstrating the core concepts of network monitoring systems.

%==============================================================================
\section{Applied Technologies}
%==============================================================================

The technology stack was carefully selected to satisfy functional requirements (network monitoring, log collection, user interface) and non-functional requirements (performance, simplicity, cross-platform compatibility).

\textbf{C++17} serves as the implementation language for the server component. C++ provides deterministic memory management, high performance, and direct access to system APIs essential for network programming and multi-threading. The use of modern C++17 features (structured bindings, \texttt{std::thread}, \texttt{std::mutex}) ensures code clarity without sacrificing performance.

\textbf{Python 3} with \textbf{PyQt6} implements the graphical client. Python's simplicity enables rapid development of the user interface, while PyQt6 (the Python bindings for Qt 6) provides a mature, cross-platform GUI framework with native look and feel.

\textbf{Qt Designer} was used to visually design the user interface. The tool generates \texttt{.ui} XML files that are loaded at runtime by PyQt6, enabling separation of UI design from application logic.

\textbf{TCP Sockets} provide the transport layer for client--server communication. TCP guarantees ordered, reliable delivery of monitoring events. The implementation uses standard POSIX socket APIs on Linux.

\textbf{Text-Based Protocol} serves as the application-level message format. Simple newline-delimited text commands (e.g., \texttt{LOGIN}, \texttt{REGISTER}, \texttt{HEARTBEAT}, \texttt{BATCH\_EVENT}) are human-readable and easily debugged using tools like Wireshark.

\textbf{SQLite} provides embedded database functionality on the server. The database stores user credentials (table \texttt{Utilizatori}) and collected logs (table \texttt{Loguri}). SQLite requires no separate database server, simplifying deployment.

\textbf{Thread Pool} architecture enables the server to handle multiple simultaneous client connections efficiently. A pool of worker threads processes incoming connections, avoiding the overhead of thread creation per connection.

%==============================================================================
\section{Application Structure}
%==============================================================================

The system comprises two main components: the C++ server and the Python client. Figure~\ref{fig:architecture} illustrates the high-level architecture.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{images/1.png}
  \caption{High-level architecture of NMS showing the client--server structure.}
  \label{fig:architecture}
\end{figure}

\subsection{Server Component}

The server runs as a native Linux binary and performs the following functions:

\begin{itemize}
  \item \textbf{Connection Management}: A main listener thread accepts incoming TCP connections on port~8080 and dispatches each connection to a worker thread from the pool.
  \item \textbf{Protocol Handling}: Worker threads parse incoming text commands, validate their structure, and route them to the appropriate processing function based on command type (LOGIN, REGISTER, HEARTBEAT, BATCH\_EVENT).
  \item \textbf{Authentication}: The LOGIN command verifies username and password against the \texttt{Utilizatori} table in SQLite using the \texttt{Autentificare()} method.
  \item \textbf{Log Storage}: BATCH\_EVENT commands are processed by the \texttt{SalveazaLog()} method, which inserts the log message into the \texttt{Loguri} table with a timestamp.
  \item \textbf{Response Generation}: Results are serialised as text responses (e.g., \texttt{ACK OK Login successful}) and transmitted back to the client.
\end{itemize}

The core thread pool mechanism is implemented using modern C++17 synchronization primitives:

\begin{lstlisting}[language=C++,caption={Thread Pool Worker Implementation (Logic\_Server.cpp).}]
void Server::FunctieThreadLucrator() {
  while (true) {
    function<void()> sarcina;
    {
      // Blocheaza mutex-ul inainte de a accesa coada
      unique_lock<mutex> blocare(mutex_coada);

      // Asteapta (doarme) pana cand apare o sarcina in coada
      conditie_trezire.wait(blocare, [this]() {
        return !coada_sarcini.empty() || opreste_serverul;
      });

      if (opreste_serverul && coada_sarcini.empty()) return;

      // Ia sarcina din fata cozii
      sarcina = move(coada_sarcini.front());
      coada_sarcini.pop();
    } 
    // Executa sarcina in afara blocarii
    sarcina();
  }
}
\end{lstlisting}

The server source files are organised as follows:
\begin{itemize}
  \item \texttt{Main\_Server.cpp} -- Entry point
  \item \texttt{Logic\_Server.cpp/h} -- Connection handling and thread pool
  \item \texttt{Commands\_Processing.cpp/h} -- Protocol command handlers
  \item \texttt{db.cpp/h} -- SQLite database wrapper (\texttt{ManagerBazaDate} class)
\end{itemize}

\subsection{Client Component}

The client is a Python application with a graphical interface built using PyQt6. It provides the following functionality:

\begin{itemize}
  \item \textbf{Connection}: Establishes TCP connection to the server using Python's \texttt{socket} module.
  \item \textbf{Authentication}: Sends LOGIN command with username and password entered in the UI. Only enables features upon successful authentication.
  \item \textbf{Log Monitoring}: A background thread (\texttt{LogMonitorThread}) continuously reads \texttt{/var/log/syslog} and sends new entries to the server using BATCH\_EVENT commands.
  \item \textbf{Manual Commands}: Buttons for REGISTER and HEARTBEAT commands.
  \item \textbf{Real-Time Display}: The log console displays sent commands, received responses, and monitored log entries in real time.
\end{itemize}

The log monitoring logic runs in a separate background thread to keep the UI responsive:

\begin{lstlisting}[language=Python,caption={Log Monitoring Thread (client\_gui.py).}]
class LogMonitorThread(QThread):
    log_signal = pyqtSignal(str)
    
    def run(self):
        # ... check file access ...
        with open(self.log_path, 'r') as f:
            f.seek(0, 2) # Jump to end of file
            while self.running and self.client.connected:
                line = f.readline()
                if line:
                    clean = line.strip()
                    if clean:
                        # Send to server via TCP
                        self.client.send(f"BATCH_EVENT {clean}")
                        self.log_signal.emit(f"[LOG] {clean[:80]}...")
                else:
                    time.sleep(0.5)
\end{lstlisting}

The client source files include:
\begin{itemize}
  \item \texttt{client\_gui.py} -- Main application with PyQt6 UI logic
  \item \texttt{mainwindows.ui} -- Qt Designer UI definition
\end{itemize}

Figure~\ref{fig:client} shows the internal architecture of the client application.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{images/2.png}
  \caption{Internal architecture of the Python client showing UI layer, network layer, monitoring threads, and signal/slot system.}
  \label{fig:client}
\end{figure}

\subsection{Database Schema}

The SQLite database (\texttt{nms\_romania.db}) contains two tables:

\begin{lstlisting}[language=SQL,caption={SQL Schema Creation (C++ embedded string).}]
CREATE TABLE IF NOT EXISTS Utilizatori (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nume_utilizator TEXT UNIQUE NOT NULL,
    parola TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS Loguri (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nume_utilizator TEXT,
    mesaj TEXT,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Inseram un user default 'admin' / 'admin' daca nu exista
INSERT OR IGNORE INTO Utilizatori (nume_utilizator, parola) 
    VALUES ('admin', 'admin');
\end{lstlisting}

\subsection{Data Flow Summary}

The complete data flow from log source to database proceeds as follows:

\begin{enumerate}
  \item Client connects to server on TCP port 8080.
  \item Server sends welcome message.
  \item Client sends LOGIN with credentials from UI.
  \item Server verifies credentials against SQLite and responds with ACK.
  \item Upon successful login, client starts log monitoring thread.
  \item Monitor thread reads new lines from \texttt{/var/log/syslog}.
  \item Each line is sent to server as BATCH\_EVENT command.
  \item Server stores the log in SQLite via \texttt{SalveazaLog()}.
  \item Server responds with ACK for each event.
  \item Client displays activity in the log console.
\end{enumerate}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{images/3.png}
  \caption{Sequence diagram showing the complete data flow: connection, authentication, log monitoring, and database storage.}
  \label{fig:dataflow}
\end{figure}

%==============================================================================
\section{Communication Protocol}
%==============================================================================

Communication uses a simple text-based protocol over TCP. Each message is a single line terminated by a newline character (\texttt{\textbackslash n}).

\subsection{Message Format}

Messages follow the format: \texttt{COMMAND [arguments...]}

\begin{lstlisting}[caption={Message format examples.}]
LOGIN admin admin
REGISTER 1.0 PyQt6-Client Linux
HEARTBEAT 3600
BATCH_EVENT 2025-12-11T16:00:00 sshd: Failed password for root
ACK OK Login successful
ACK FAIL Invalid credentials
\end{lstlisting}

\subsection{Command Types}

The protocol defines five command types:

\textbf{LOGIN}: Sent by client to authenticate.
\begin{lstlisting}
LOGIN <username> <password>
\end{lstlisting}

\textbf{REGISTER}: Sent by client to register as a monitoring agent.
\begin{lstlisting}
REGISTER <version> <hostname> <os>
\end{lstlisting}

\textbf{HEARTBEAT}: Sent periodically to indicate liveness.
\begin{lstlisting}
HEARTBEAT <uptime_seconds>
\end{lstlisting}

\textbf{BATCH\_EVENT}: Sends a log entry to the server.
\begin{lstlisting}
BATCH_EVENT <log_message>
\end{lstlisting}

\textbf{ACK}: Server response acknowledging a command.
\begin{lstlisting}
ACK <status> <message>
\end{lstlisting}

\subsection{Port Assignment}

\begin{table}[ht]
\centering
\caption{Network port assignment.}
\label{tab:ports}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Port} & \textbf{Protocol} & \textbf{Direction} & \textbf{Purpose} \\
\midrule
8080 & TCP & Client $\rightarrow$ Server & Primary communication \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Wireshark Analysis}

The text protocol enables easy debugging with Wireshark. Using the filter \texttt{tcp.port == 8080} on the loopback interface (\texttt{lo}), the complete conversation can be observed:

\begin{lstlisting}[caption={Example Wireshark TCP stream.}]
Bine ai venit la server!
LOGIN admin admin
ACK OK Login successful
REGISTER 1.0 PyQt6-Client Linux
ACK OK Registration successful
BATCH_EVENT 2025-12-11T16:00:00 sshd: session opened
ACK OK Event received
\end{lstlisting}

\subsection{Connection State Machine}

Figure~\ref{fig:statemachine} shows the state transitions for a client connection lifecycle, from initial connection through authentication, monitoring, and disconnection.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{images/4.png}
  \caption{State machine diagram showing client connection lifecycle: Disconnected, Connecting, Authenticating, Authenticated (with Monitoring substates), Reconnecting, and Disconnecting.}
  \label{fig:statemachine}
\end{figure}

%==============================================================================
\section{Real World Use Cases}
%==============================================================================

This section describes six operational scenarios---three successful and three involving system failures---demonstrating the platform's utility in a production environment.

\subsection{Successful Execution Scenarios}

\textbf{1. Centralized Security Auditing (Incident Detection)}\\
\textit{Use Case:} A security administrator needs to investigate a potential breach on the ``Finance-Server'' node.\\
\textit{Execution:} The administrator launches the NMS client and authenticates successfully. They observe the real-time stream of log messages. When the remote node generates \texttt{sshd} failure logs, these are immediately propagated to the central dashboard.\\
\textit{Result:} The administrator identifies the source IP of the attacker in real-time, allowing for immediate remediation. The system successfully aggregates distributed intelligence into a single view.

\textbf{2. Infrastructure Scalability (New Node Provisioning)}\\
\textit{Use Case:} A DevOps engineer adds a new web server to the existing fleet and requires immediate monitoring status.\\
\textit{Execution:} The engineer deploys the NMS Agent on the new server. Upon startup, the agent automatically initiates the registration process, transmitting its OS details (Linux Ubuntu) and hostname.\\
\textit{Result:} The server accepts the registration without requiring a restart or manual configuration update. The new node immediately begins contributing heartbeat data, verifying the successful expansion of the monitoring perimeter.

\textbf{3. Continuous Availability Monitoring (Heartbeat Tracking)}\\
\textit{Use Case:} Network operations staff need to verify that a critical gateway remains online during a weekend maintenance window.\\
\textit{Execution:} The agent is configured to send periodic heartbeat signals. The server processes these keep-alive messages continuously.\\
\textit{Result:} The server records the periodic signals in the database. The operations team can visually confirm the ``Alive'' status of the gateway throughout the maintenance window, ensuring Service Level Agreements (SLAs) are met.

\subsection{Failure Scenarios and Handling}

\textbf{1. Unauthorized Access Attempt (Insider Threat)}\\
\textit{Use Case:} An unprivileged user attempts to gain access to the NMS dashboard to delete log evidence.\\
\textit{Execution:} The user launches the client and attempts to guess the administrator password, sending invalid credentials.\\
\textit{System Response:} The server performs a check against the \texttt{Utilizatori} table and returns a failure response. The client application enforces a strict lockout, keeping the ``Monitoring'' and ``History'' features disabled. The security of the stored logs is preserved despite the attempted breach.

\textbf{2. Central Server Outage (Network Partition)}\\
\textit{Use Case:} A remote branch office loses VPN connectivity to the main datacenter where the NMS Server resides.\\
\textit{Execution:} The branch agent attempts to transmit a batch of syslog entries, but the TCP handshake fails due to the network path being down.\\
\textit{System Response:} Instead of crashing, the client catches the network exception. It logs a local error state and alerts the user via the UI. The agent enters a ``Disconnected'' state, preventing data loss attempts until connectivity is restored.

\textbf{3. Malformed Data Injection (Integrity Protection)}\\
\textit{Use Case:} A compromised host attempts to crash the monitoring server by sending corrupted or non-compliant protocol messages.\\
\textit{Execution:} The malicious agent sends a string that violates the protocol format (e.g., missing command headers or binary garbage).\\
\textit{System Response:} The server's command parser detects the anomaly. It classifies the message as unknown or handles the parsing exception safely. The server drops the invalid packet, logs the error to standard output, and maintains the stability of the main thread pool for other legitimate clients.

%==============================================================================
\section{Conclusion}
%==============================================================================

This work presents NMS, a functional client--server platform for network monitoring and log collection. The system successfully demonstrates centralised log collection, user authentication, and real-time visualisation.

The architecture provides clear separation of concerns: the C++ server handles network connections and database operations with high performance, while the Python client provides a user-friendly graphical interface. The text-based protocol simplifies debugging and integration.

\subsection{Potential Improvements}

Several enhancements could extend the platform's capabilities:

\begin{itemize}
  \item \textbf{Password Hashing}: Store hashed passwords instead of plaintext.
  \item \textbf{TLS Encryption}: Add SSL/TLS for secure communication over untrusted networks.
  \item \textbf{Log Filtering}: Allow clients to filter logs by severity, source, or keyword.
  \item \textbf{Dashboard Statistics}: Display charts showing log volume, error rates, and trends.
  \item \textbf{Multiple Log Sources}: Support monitoring of additional log files beyond syslog.
  \item \textbf{User Management}: Add ability to create and manage multiple user accounts.
\end{itemize}

%==============================================================================
\begin{thebibliography}{99}

\bibitem{tcpip}
Stevens, W.R.: TCP/IP Illustrated, Volume 1: The Protocols. Addison-Wesley (1994).

\bibitem{sqlite}
SQLite Consortium: SQLite Documentation. \url{https://www.sqlite.org/docs.html}. Accessed: 11 December 2025.

\bibitem{pyqt6}
Riverbank Computing: PyQt6 Documentation. \url{https://www.riverbankcomputing.com/static/Docs/PyQt6/}. Accessed: 11 December 2025.

\bibitem{qt6}
The Qt Company: Qt 6 Documentation. \url{https://doc.qt.io/qt-6/}. Accessed: 11 December 2025.

\bibitem{posix}
IEEE: POSIX.1-2017 -- Portable Operating System Interface. IEEE Std 1003.1 (2017).

\bibitem{cpp17}
ISO: ISO/IEC 14882:2017 -- Programming Language C++. International Organization for Standardization (2017).

\bibitem{wazuh}
Wazuh, Inc.: Wazuh -- The Open Source Security Platform. \url{https://wazuh.com}. Accessed: 11 December 2025.

\bibitem{wazuh-github}
Wazuh, Inc.: Wazuh GitHub Repository. \url{https://github.com/wazuh/wazuh}. Accessed: 11 December 2025.

\bibitem{rfc5424}
Gerhards, R.: The Syslog Protocol. RFC 5424, IETF (2009).

\bibitem{campus_nms}
Olusola, O. et al.: Design and Implementation of Network Monitoring System for Campus Infrastructure Using Software Agents. In: Journal of Computer Networks and Communications (2021).

\end{thebibliography}

\end{document}
